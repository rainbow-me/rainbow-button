{"id":"../node_modules/@stablelib/wipe/lib/wipe.js","dependencies":[{"name":"/Users/estebanmino/repos/rainbow-button/node_modules/@stablelib/wipe/lib/wipe.js.map","includedInParent":true,"mtime":1626136941541},{"name":"/Users/estebanmino/repos/rainbow-button/node_modules/@stablelib/wipe/wipe.ts","includedInParent":true,"mtime":1626136941541},{"name":"/Users/estebanmino/repos/rainbow-button/example/package.json","includedInParent":true,"mtime":1627438800374},{"name":"/Users/estebanmino/repos/rainbow-button/node_modules/@stablelib/wipe/package.json","includedInParent":true,"mtime":1626136941541}],"generated":{"js":"\"use strict\";\n// Copyright (C) 2016 Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Sets all values in the given array to zero and returns it.\n *\n * The fact that it sets bytes to zero can be relied on.\n *\n * There is no guarantee that this function makes data disappear from memory,\n * as runtime implementation can, for example, have copying garbage collector\n * that will make copies of sensitive data before we wipe it. Or that an\n * operating system will write our data to swap or sleep image. Another thing\n * is that an optimizing compiler can remove calls to this function or make it\n * no-op. There's nothing we can do with it, so we just do our best and hope\n * that everything will be okay and good will triumph over evil.\n */\nfunction wipe(array) {\n    // Right now it's similar to array.fill(0). If it turns\n    // out that runtimes optimize this call away, maybe\n    // we can try something else.\n    for (var i = 0; i < array.length; i++) {\n        array[i] = 0;\n    }\n    return array;\n}\nexports.wipe = wipe;\n"},"sourceMaps":{"js":{"version":3,"file":"wipe.js","sourceRoot":"","sources":["../wipe.ts"],"names":[],"mappings":";AAAA,sCAAsC;AACtC,6CAA6C;;AAS7C;;;;;;;;;;;;GAYG;AACH,SAAgB,IAAI,CAAC,KAAmB;IACpC,uDAAuD;IACvD,mDAAmD;IACnD,6BAA6B;IAC7B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;QACnC,KAAK,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;KAChB;IACD,OAAO,KAAK,CAAC;AACjB,CAAC;AARD,oBAQC","sourcesContent":["// Copyright (C) 2016 Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\n\n/**\n * Package wipe implements functions for zeroing arrays.\n */\n\nexport type NumericArray = number[] | Uint8Array | Int8Array | Uint16Array\n    | Int16Array | Uint32Array | Int32Array | Float32Array | Float64Array;\n\n/**\n * Sets all values in the given array to zero and returns it.\n *\n * The fact that it sets bytes to zero can be relied on.\n *\n * There is no guarantee that this function makes data disappear from memory,\n * as runtime implementation can, for example, have copying garbage collector\n * that will make copies of sensitive data before we wipe it. Or that an\n * operating system will write our data to swap or sleep image. Another thing\n * is that an optimizing compiler can remove calls to this function or make it\n * no-op. There's nothing we can do with it, so we just do our best and hope\n * that everything will be okay and good will triumph over evil.\n */\nexport function wipe(array: NumericArray): NumericArray {\n    // Right now it's similar to array.fill(0). If it turns\n    // out that runtimes optimize this call away, maybe\n    // we can try something else.\n    for (let i = 0; i < array.length; i++) {\n        array[i] = 0;\n    }\n    return array;\n}\n"]}},"error":null,"hash":"b135467a0e5474869c9f6b984c390d21","cacheData":{"env":{}}}